use crate::types::*;

use lib_ruby_parser::Node;
use napi::bindgen_prelude::{Either20, Either26, Either5};
use napi_derive::napi;

pub type RubyNode = Either5<
  Either26<
    Alias,
    And,
    AndAsgn,
    Arg,
    Args,
    Array,
    ArrayPattern,
    ArrayPatternWithTail,
    BackRef,
    Begin,
    Block,
    Blockarg,
    BlockPass,
    Break,
    Case,
    CaseMatch,
    Casgn,
    Cbase,
    Class,
    Complex,
    Const,
    ConstPattern,
    CSend,
    Cvar,
    Cvasgn,
    Def,
  >,
  Either26<
    Defined,
    Defs,
    Dstr,
    Dsym,
    EFlipFlop,
    EmptyElse,
    Encoding,
    Ensure,
    Erange,
    False,
    File,
    FindPattern,
    Float,
    For,
    ForwardArg,
    ForwardedArgs,
    Gvar,
    Gvasgn,
    Hash,
    HashPattern,
    Heredoc,
    If,
    IfGuard,
    IFlipFlop,
    IfMod,
    IfTernary,
  >,
  Either26<
    Index,
    IndexAsgn,
    InPattern,
    Int,
    Irange,
    Ivar,
    Ivasgn,
    Kwarg,
    Kwargs,
    KwBegin,
    Kwnilarg,
    Kwoptarg,
    Kwrestarg,
    Kwsplat,
    Lambda,
    Line,
    Lvar,
    Lvasgn,
    Masgn,
    MatchAlt,
    MatchAs,
    MatchCurrentLine,
    MatchNilPattern,
    MatchPattern,
    MatchPatternP,
    MatchRest,
  >,
  Either26<
    MatchVar,
    MatchWithLvasgn,
    Mlhs,
    Module,
    Next,
    Nil,
    NthRef,
    Numblock,
    OpAsgn,
    Optarg,
    Or,
    OrAsgn,
    Pair,
    Pin,
    Postexe,
    Preexe,
    Procarg0,
    Rational,
    Redo,
    Regexp,
    RegOpt,
    Rescue,
    RescueBody,
    Restarg,
    Retry,
    Return,
  >,
  Either20<
    SClass,
    RubySelf,
    Send,
    Shadowarg,
    Splat,
    Str,
    Super,
    Sym,
    True,
    Undef,
    UnlessGuard,
    Until,
    UntilPost,
    When,
    While,
    WhilePost,
    XHeredoc,
    Xstr,
    Yield,
    ZSuper,
  >,
>;

pub fn from_node(node: Node) -> RubyNode {
  match node {
    Node::Alias(val) => Either5::A(Either26::A(Alias::from(val))),
    Node::And(val) => Either5::A(Either26::B(And::from(val))),
    Node::AndAsgn(val) => Either5::A(Either26::C(AndAsgn::from(val))),
    Node::Arg(val) => Either5::A(Either26::D(Arg::from(val))),
    Node::Args(val) => Either5::A(Either26::E(Args::from(val))),
    Node::Array(val) => Either5::A(Either26::F(Array::from(val))),
    Node::ArrayPattern(val) => Either5::A(Either26::G(ArrayPattern::from(val))),
    Node::ArrayPatternWithTail(val) => Either5::A(Either26::H(ArrayPatternWithTail::from(val))),
    Node::BackRef(val) => Either5::A(Either26::I(BackRef::from(val))),
    Node::Begin(val) => Either5::A(Either26::J(Begin::from(val))),
    Node::Block(val) => Either5::A(Either26::K(Block::from(val))),
    Node::Blockarg(val) => Either5::A(Either26::L(Blockarg::from(val))),
    Node::BlockPass(val) => Either5::A(Either26::M(BlockPass::from(val))),
    Node::Break(val) => Either5::A(Either26::N(Break::from(val))),
    Node::Case(val) => Either5::A(Either26::O(Case::from(val))),
    Node::CaseMatch(val) => Either5::A(Either26::P(CaseMatch::from(val))),
    Node::Casgn(val) => Either5::A(Either26::Q(Casgn::from(val))),
    Node::Cbase(val) => Either5::A(Either26::R(Cbase::from(val))),
    Node::Class(val) => Either5::A(Either26::S(Class::from(val))),
    Node::Complex(val) => Either5::A(Either26::T(Complex::from(val))),
    Node::Const(val) => Either5::A(Either26::U(Const::from(val))),
    Node::ConstPattern(val) => Either5::A(Either26::V(ConstPattern::from(val))),
    Node::CSend(val) => Either5::A(Either26::W(CSend::from(val))),
    Node::Cvar(val) => Either5::A(Either26::X(Cvar::from(val))),
    Node::Cvasgn(val) => Either5::A(Either26::Y(Cvasgn::from(val))),
    Node::Def(val) => Either5::A(Either26::Z(Def::from(val))),

    Node::Defined(val) => Either5::B(Either26::A(Defined::from(val))),
    Node::Defs(val) => Either5::B(Either26::B(Defs::from(val))),
    Node::Dstr(val) => Either5::B(Either26::C(Dstr::from(val))),
    Node::Dsym(val) => Either5::B(Either26::D(Dsym::from(val))),
    Node::EFlipFlop(val) => Either5::B(Either26::E(EFlipFlop::from(val))),
    Node::EmptyElse(val) => Either5::B(Either26::F(EmptyElse::from(val))),
    Node::Encoding(val) => Either5::B(Either26::G(Encoding::from(val))),
    Node::Ensure(val) => Either5::B(Either26::H(Ensure::from(val))),
    Node::Erange(val) => Either5::B(Either26::I(Erange::from(val))),
    Node::False(val) => Either5::B(Either26::J(False::from(val))),
    Node::File(val) => Either5::B(Either26::K(File::from(val))),
    Node::FindPattern(val) => Either5::B(Either26::L(FindPattern::from(val))),
    Node::Float(val) => Either5::B(Either26::M(Float::from(val))),
    Node::For(val) => Either5::B(Either26::N(For::from(val))),
    Node::ForwardArg(val) => Either5::B(Either26::O(ForwardArg::from(val))),
    Node::ForwardedArgs(val) => Either5::B(Either26::P(ForwardedArgs::from(val))),
    Node::Gvar(val) => Either5::B(Either26::Q(Gvar::from(val))),
    Node::Gvasgn(val) => Either5::B(Either26::R(Gvasgn::from(val))),
    Node::Hash(val) => Either5::B(Either26::S(Hash::from(val))),
    Node::HashPattern(val) => Either5::B(Either26::T(HashPattern::from(val))),
    Node::Heredoc(val) => Either5::B(Either26::U(Heredoc::from(val))),
    Node::If(val) => Either5::B(Either26::V(If::from(val))),
    Node::IfGuard(val) => Either5::B(Either26::W(IfGuard::from(val))),
    Node::IFlipFlop(val) => Either5::B(Either26::X(IFlipFlop::from(val))),
    Node::IfMod(val) => Either5::B(Either26::Y(IfMod::from(val))),
    Node::IfTernary(val) => Either5::B(Either26::Z(IfTernary::from(val))),

    Node::Index(val) => Either5::C(Either26::A(Index::from(val))),
    Node::IndexAsgn(val) => Either5::C(Either26::B(IndexAsgn::from(val))),
    Node::InPattern(val) => Either5::C(Either26::C(InPattern::from(val))),
    Node::Int(val) => Either5::C(Either26::D(Int::from(val))),
    Node::Irange(val) => Either5::C(Either26::E(Irange::from(val))),
    Node::Ivar(val) => Either5::C(Either26::F(Ivar::from(val))),
    Node::Ivasgn(val) => Either5::C(Either26::G(Ivasgn::from(val))),
    Node::Kwarg(val) => Either5::C(Either26::H(Kwarg::from(val))),
    Node::Kwargs(val) => Either5::C(Either26::I(Kwargs::from(val))),
    Node::KwBegin(val) => Either5::C(Either26::J(KwBegin::from(val))),
    Node::Kwnilarg(val) => Either5::C(Either26::K(Kwnilarg::from(val))),
    Node::Kwoptarg(val) => Either5::C(Either26::L(Kwoptarg::from(val))),
    Node::Kwrestarg(val) => Either5::C(Either26::M(Kwrestarg::from(val))),
    Node::Kwsplat(val) => Either5::C(Either26::N(Kwsplat::from(val))),
    Node::Lambda(val) => Either5::C(Either26::O(Lambda::from(val))),
    Node::Line(val) => Either5::C(Either26::P(Line::from(val))),
    Node::Lvar(val) => Either5::C(Either26::Q(Lvar::from(val))),
    Node::Lvasgn(val) => Either5::C(Either26::R(Lvasgn::from(val))),
    Node::Masgn(val) => Either5::C(Either26::S(Masgn::from(val))),
    Node::MatchAlt(val) => Either5::C(Either26::T(MatchAlt::from(val))),
    Node::MatchAs(val) => Either5::C(Either26::U(MatchAs::from(val))),
    Node::MatchCurrentLine(val) => Either5::C(Either26::V(MatchCurrentLine::from(val))),
    Node::MatchNilPattern(val) => Either5::C(Either26::W(MatchNilPattern::from(val))),
    Node::MatchPattern(val) => Either5::C(Either26::X(MatchPattern::from(val))),
    Node::MatchPatternP(val) => Either5::C(Either26::Y(MatchPatternP::from(val))),
    Node::MatchRest(val) => Either5::C(Either26::Z(MatchRest::from(val))),

    Node::MatchVar(val) => Either5::D(Either26::A(MatchVar::from(val))),
    Node::MatchWithLvasgn(val) => Either5::D(Either26::B(MatchWithLvasgn::from(val))),
    Node::Mlhs(val) => Either5::D(Either26::C(Mlhs::from(val))),
    Node::Module(val) => Either5::D(Either26::D(Module::from(val))),
    Node::Next(val) => Either5::D(Either26::E(Next::from(val))),
    Node::Nil(val) => Either5::D(Either26::F(Nil::from(val))),
    Node::NthRef(val) => Either5::D(Either26::G(NthRef::from(val))),
    Node::Numblock(val) => Either5::D(Either26::H(Numblock::from(val))),
    Node::OpAsgn(val) => Either5::D(Either26::I(OpAsgn::from(val))),
    Node::Optarg(val) => Either5::D(Either26::J(Optarg::from(val))),
    Node::Or(val) => Either5::D(Either26::K(Or::from(val))),
    Node::OrAsgn(val) => Either5::D(Either26::L(OrAsgn::from(val))),
    Node::Pair(val) => Either5::D(Either26::M(Pair::from(val))),
    Node::Pin(val) => Either5::D(Either26::N(Pin::from(val))),
    Node::Postexe(val) => Either5::D(Either26::O(Postexe::from(val))),
    Node::Preexe(val) => Either5::D(Either26::P(Preexe::from(val))),
    Node::Procarg0(val) => Either5::D(Either26::Q(Procarg0::from(val))),
    Node::Rational(val) => Either5::D(Either26::R(Rational::from(val))),
    Node::Redo(val) => Either5::D(Either26::S(Redo::from(val))),
    Node::Regexp(val) => Either5::D(Either26::T(Regexp::from(val))),
    Node::RegOpt(val) => Either5::D(Either26::U(RegOpt::from(val))),
    Node::Rescue(val) => Either5::D(Either26::V(Rescue::from(val))),
    Node::RescueBody(val) => Either5::D(Either26::W(RescueBody::from(val))),
    Node::Restarg(val) => Either5::D(Either26::X(Restarg::from(val))),
    Node::Retry(val) => Either5::D(Either26::Y(Retry::from(val))),
    Node::Return(val) => Either5::D(Either26::Z(Return::from(val))),

    Node::SClass(val) => Either5::E(Either20::A(SClass::from(val))),
    Node::Self_(val) => Either5::E(Either20::B(RubySelf::from(val))),
    Node::Send(val) => Either5::E(Either20::C(Send::from(val))),
    Node::Shadowarg(val) => Either5::E(Either20::D(Shadowarg::from(val))),
    Node::Splat(val) => Either5::E(Either20::E(Splat::from(val))),
    Node::Str(val) => Either5::E(Either20::F(Str::from(val))),
    Node::Super(val) => Either5::E(Either20::G(Super::from(val))),
    Node::Sym(val) => Either5::E(Either20::H(Sym::from(val))),
    Node::True(val) => Either5::E(Either20::I(True::from(val))),
    Node::Undef(val) => Either5::E(Either20::J(Undef::from(val))),
    Node::UnlessGuard(val) => Either5::E(Either20::K(UnlessGuard::from(val))),
    Node::Until(val) => Either5::E(Either20::L(Until::from(val))),
    Node::UntilPost(val) => Either5::E(Either20::M(UntilPost::from(val))),
    Node::When(val) => Either5::E(Either20::N(When::from(val))),
    Node::While(val) => Either5::E(Either20::O(While::from(val))),
    Node::WhilePost(val) => Either5::E(Either20::P(WhilePost::from(val))),
    Node::XHeredoc(val) => Either5::E(Either20::Q(XHeredoc::from(val))),
    Node::Xstr(val) => Either5::E(Either20::R(Xstr::from(val))),
    Node::Yield(val) => Either5::E(Either20::S(Yield::from(val))),
    Node::ZSuper(val) => Either5::E(Either20::T(ZSuper::from(val))),

    val => {
      // show unsupported node type
      println!("{:?}", val);
      panic!("Unsupported node type");
    }
  }
}

#[napi]
pub enum RubyNodeType {
  Alias,
  And,
  AndAsgn,
  Arg,
  Args,
  Array,
  ArrayPattern,
  ArrayPatternWithTail,
  BackRef,
  Begin,
  Block,
  Blockarg,
  BlockPass,
  Break,
  Case,
  CaseMatch,
  Casgn,
  Cbase,
  Class,
  Complex,
  Const,
  ConstPattern,
  CSend,
  Cvar,
  Cvasgn,
  Def,
  Defined,
  Defs,
  Dstr,
  Dsym,
  EFlipFlop,
  EmptyElse,
  Encoding,
  Ensure,
  Erange,
  False,
  File,
  FindPattern,
  Float,
  For,
  ForwardArg,
  ForwardedArgs,
  Gvar,
  Gvasgn,
  Hash,
  HashPattern,
  Heredoc,
  If,
  IfGuard,
  IFlipFlop,
  IfMod,
  IfTernary,
  Index,
  IndexAsgn,
  InPattern,
  Int,
  Irange,
  Ivar,
  Ivasgn,
  Kwarg,
  Kwargs,
  KwBegin,
  Kwnilarg,
  Kwoptarg,
  Kwrestarg,
  Kwsplat,
  Lambda,
  Line,
  Lvar,
  Lvasgn,
  Masgn,
  MatchAlt,
  MatchAs,
  MatchCurrentLine,
  MatchNilPattern,
  MatchPattern,
  MatchPatternP,
  MatchRest,
  MatchVar,
  MatchWithLvasgn,
  Mlhs,
  Module,
  Next,
  Nil,
  NthRef,
  Numblock,
  OpAsgn,
  Optarg,
  Or,
  OrAsgn,
  Pair,
  Pin,
  Postexe,
  Preexe,
  Procarg0,
  Rational,
  Redo,
  Regexp,
  RegOpt,
  Rescue,
  RescueBody,
  Restarg,
  Retry,
  Return,
  SClass,
  RubySelf,
  Send,
  Shadowarg,
  Splat,
  Str,
  Super,
  Sym,
  True,
  Undef,
  UnlessGuard,
  Until,
  UntilPost,
  When,
  While,
  WhilePost,
  XHeredoc,
  Xstr,
  Yield,
  ZSuper,
}
