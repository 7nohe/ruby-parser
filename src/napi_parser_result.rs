use crate::types::*;

use lib_ruby_parser::Node;
use napi::{bindgen_prelude::{Either26, Either11}, Either};
use napi_derive::napi;

pub type RubyNode = Either<
  Either26<
    Alias,
    AndAsgn,
    Send,
    Str,
    Begin,
    Class,
    Const,
    Cbase,
    Sym,
    Undef,
    Def,
    Args,
    Arg,
    Mlhs,
    Optarg,
    Lvar,
    Restarg,
    Kwarg,
    Kwoptarg,
    Kwrestarg,
    Blockarg,
    Defs,
    RubySelf,
    Int,
    Module,
    SClass,
  >,
  Either11<Casgn, ForwardArg, Kwnilarg, Preexe, Postexe, File, Line, Encoding, True, False, Nil>,
>;

pub fn from_node(node: Node) -> RubyNode {
  match node {
    Node::Alias(val) => Either::A(Either26::A(Alias::from(val))),
    Node::AndAsgn(val) => Either::A(Either26::B(AndAsgn::from(val))),
    Node::Send(val) => Either::A(Either26::C(Send::from(val))),
    Node::Str(val) => Either::A(Either26::D(Str::from(val))),
    Node::Begin(val) => Either::A(Either26::E(Begin::from(val))),
    Node::Class(val) => Either::A(Either26::F(Class::from(val))),
    Node::Const(val) => Either::A(Either26::G(Const::from(val))),
    Node::Cbase(val) => Either::A(Either26::H(Cbase::from(val))),
    Node::Sym(val) => Either::A(Either26::I(Sym::from(val))),
    Node::Undef(val) => Either::A(Either26::J(Undef::from(val))),
    Node::Def(val) => Either::A(Either26::K(Def::from(val))),
    Node::Args(val) => Either::A(Either26::L(Args::from(val))),
    Node::Arg(val) => Either::A(Either26::M(Arg::from(val))),
    Node::Mlhs(val) => Either::A(Either26::N(Mlhs::from(val))),
    Node::Optarg(val) => Either::A(Either26::O(Optarg::from(val))),
    Node::Lvar(val) => Either::A(Either26::P(Lvar::from(val))),
    Node::Restarg(val) => Either::A(Either26::Q(Restarg::from(val))),
    Node::Kwarg(val) => Either::A(Either26::R(Kwarg::from(val))),
    Node::Kwoptarg(val) => Either::A(Either26::S(Kwoptarg::from(val))),
    Node::Kwrestarg(val) => Either::A(Either26::T(Kwrestarg::from(val))),
    Node::Blockarg(val) => Either::A(Either26::U(Blockarg::from(val))),
    Node::Defs(val) => Either::A(Either26::V(Defs::from(val))),
    Node::Self_(val) => Either::A(Either26::W(RubySelf::from(val))),
    Node::Int(val) => Either::A(Either26::X(Int::from(val))),
    Node::Module(val) => Either::A(Either26::Y(Module::from(val))),
    Node::SClass(val) => Either::A(Either26::Z(SClass::from(val))),
    Node::Casgn(val) => Either::B(Either11::A(Casgn::from(val))),
    Node::ForwardArg(val) => Either::B(Either11::B(ForwardArg::from(val))),
    Node::Kwnilarg(val) => Either::B(Either11::C(Kwnilarg::from(val))),
    Node::Preexe(val) => Either::B(Either11::D(Preexe::from(val))),
    Node::Postexe(val) => Either::B(Either11::E(Postexe::from(val))),
    Node::File(val) => Either::B(Either11::F(File::from(val))),
    Node::Line(val) => Either::B(Either11::G(Line::from(val))),
    Node::Encoding(val) => Either::B(Either11::H(Encoding::from(val))),
    Node::True(val) => Either::B(Either11::I(True::from(val))),
    Node::False(val) => Either::B(Either11::J(False::from(val))),
    Node::Nil(val) => Either::B(Either11::K(Nil::from(val))),
    val => {
      // show unsupported node type
      println!("{:?}", val);
      panic!("Unsupported node type");
    }
  }
}

#[napi]
pub enum RubyNodeType {
  Alias,
  AndAsgn,
  Send,
  Str,
  Begin,
  Class,
  Const,
  Cbase,
  Sym,
  Undef,
  Def,
  Args,
  Arg,
  Mlhs,
  Optarg,
  Lvar,
  Restarg,
  Kwarg,
  Kwoptarg,
  Kwrestarg,
  Blockarg,
  Defs,
  RubySelf,
  Int,
  Module,
  SClass,
  Casgn,
  ForwardArg,
  Kwnilarg,
  Preexe,
  Postexe,
  File,
  Line,
  Encoding,
  True,
  False,
  Nil,
}
